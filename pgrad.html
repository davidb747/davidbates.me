---
layout: article
title: Policy Gradient Methods
date: 2022-12-14
sidebar:
  nav: "docs-en"
---
<!DOCTYPE HTML>
<html>


<!--- Adding Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154990580-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154990580-2');
</script>
<!-- End of Google Analytics Code -->
<!-- Adding MathJAX -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script async="true" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=AM_CHTML"> </script>
<!-- End of MathJAX -->



<body>
	
        <p>Unlike other methods where we first learn the <i>value of actions</i> and then select action based on estimated <i>action-values</i>, here in Policy Gradient Methods, we use <i>parameterized policy</i> that can select actions without consulting a value function.</p>
        <p>If we use `&theta; &isin; &Ropf;^d` for the policy's parameter vector, and then probability for the action `a` is taken at time `t` given environment is in state `s` with parameter `&theta;` is given by :</p>
        <p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&pi;(a | s,&theta;) = Pr{A_(t) = a | S_(t) = s, &theta;_(t) = &theta;}`</p>
        <p>Here, we seek to learn the policy parameter based on the gradient of some scalar performance measure `J(&theta;)` i.e, </p>
        <p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&theta;_(t + 1) = &theta;_(t) + &alpha;\hat(&nabla;J(&theta;_(t)))`&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;..eq(1)</p>
        <p>where `\hat(&nabla;J(&theta;_(t)))&isin;&Ropf;^d` is a stochastic estimate whose expectation approximates the gradient of the performance measure with respect to its argument `&theta;_(t)`.<br>
        Methods following these schema are called <i>Policy Gradient Methods</i><br>
        Whereas, methods that learn its approximations to both policy and value function are called <i>Actor-Critic Methods</i></p>
        <p style="font-size: 17px;"><b>Policy Approximation and its Advantages </b></p>
        <p>In policy gradient methods, the policy can be parameterized in any way, as long as `&pi;(a |s, &theta;)` is differentiable with respect to its parameters, and to ensure exploration, we need policy to never become deterministic i.e, `&pi;(a |s,&theta;) &isin;(0,1)` for all `s,a,&theta;`</p>
        <p>If the action space is discrete, and not too large, then parameterization can be done by forming numerical preferences `h(s,a,&theta;)&isin;&Ropf;` for each state-action pair. The action with the highest preferences in each state are given the highest probabilities of being selected as per exponential soft-max distribution :</p>
        <p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&pi;(a |s,&theta;) &esdot; \frac{e^(h(s,a,&theta;))}{\sum_(b)e^(h(s,b,&theta;))}`</p>
		<p>This kind of policy parameterization is called <i>soft-max in action preferences</i>. Importantly, action preferences can also be parameterized either by ANN using `&theta;` as a vector of weights. Or it could be linear in features, i.e, `h(s,a,&theta;) = &theta;^T x(s,a)` using feature vectors `x(s,a)&isin;&Ropf;`</p>
		<p><u><b>Advantages</b></u></p>
		<p>1. With this, the action probabilities change smoothly as a function of the learned parameter, whereas in `&epsilon;-`greedy it can change dramatically. For example, for a small change in the estimated action-value, the result can have maximal value. Thus, policy parameterization guarantees stronger convergence.<br>
			2. As in problems with significant function approximation, the best approximate policy can be stochastic. Parameterizing policy method help find optimal stochastic policy.<br>
			3. It learns faster and yields a better asymptotic policy.<br>
			4. It can help inject prior knowledge about the desired form of the policy into the RL system.
		</p>
		<h2>The Policy Gradient Theorem</h2>
		<p>Episodic and continuing cases define the performance measure, `J(&theta;)` differently.</p>
		<p><u>In episodic cases,</u> the performance is define as :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`J(&theta;) &esdot;v_(&pi;_(&theta;))(s_(0))`</p>
		<p>where `v_(&pi;_(&theta;))` is the true value function for `&pi;_(&theta;)`, the policy determined by `&theta;`, assuming no discounting i.e, `&gamma;=1`</p>
		<p><u>In continuing cases,</u> the performance is defined in terms of the average rate of reward per time step :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`J(&theta;) &esdot; lim_{h&rarr;&infin;} \frac{1}{h}\sum_{t=1}^h`&Eopf;`[R_(t) | S_(0), A_(0:t-1) ~&pi;]`<br>
		&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`= lim_{t&rarr;&infin;}`&Eopf;`[R_(t) | S_(0), A_(0:t-1) ~&pi;]`<br>
		&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`=\sum_{s}&mu;(s)\sum_{a}&pi;(a | s) \sum_{s',r}p(s',r |s,a)r`
		</p>

		<p><u>Challenge :</u> Policy parameter determines both the action selections and the distribution of states in which those selections are made. Given a state, the effect of the policy parameter on the action can be computed, however, the state distribution is unknown.</p>
		<p><i>Policy Gradient Theorem</i> solves this by providing expression for the gradient of performance w.r.t. policy parameter that <u>does not</u> involve derivatives of state distribution. It establishes that :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&nabla;J(&theta;)&prop;\sum_{s}&mu;(s)\sum_{a}q_(&pi;)(s,a)&nabla;&pi;(a | s,&theta;)`&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...eq(2)</p>

		<h2>REINFORCE : Monte Carlo Policy Gradient</h2>
		<p>In eq(2), policy gradient theorem is a sum over states weighted by how often the sum sum occur under the target policy `&pi;`. Thus, it can be written as : </p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;`&nabla;J(&theta;)&prop;\sum_{s}&mu;(s)\sum_{a}q_(&pi;)(s,a)&nabla;&pi;(a | s,&theta;)`<br>
		&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`= `&Eopf;<sub>`pi`</sub>`[\sum_{a}q_(&pi;)(S_(t),a)&nabla;&pi;(a | S_(t),&theta;)]`&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...eq(3)</p>
		<p>Now, stochastic gradient ascent algorithm in eq(1) can be expressed as :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&theta;_(t+1) &esdot; &theta;_(t) + &alpha;\sum_{a}\hatq(S_(t),a,W)&nabla;&pi;(a | S_(t),&theta;)`&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;...eq(4)</p>
		<p>where `\hatq` is some learned approximation to `q_(&pi;)`. This algorithm is called the <i>all-actions</i> method because its update involves all of the actions.
		REINFORCE algorithm, however, only updates `A_(t)` and time `t` - the one action actually taken at `t`</p>
		<p>In eq(3), if we introduce weighting to the appropriate sum over actions, without changing the equality, by multiplying and dividing the term by `&pi;(a | S_(t),&theta;)`, we have :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;`&nabla;J(&theta;) = `&Eopf;<sub>`pi`</sub>`[\sum_{a}&pi;(a | S_(t),&theta;)q_(&pi;)(S_(t),a)\frac{&nabla;&pi;(a | S_(t),&theta;)}{&pi;(a | S_(t),&theta;)}]`</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`= `&Eopf;<sub>`pi`</sub>`[q_(&pi;)(S_(t),A_(t))\frac{&nabla;&pi;(A_(t) | S_(t),&theta;)}{&pi;(A_(t) | S_(t),&theta;)}]`</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`= `&Eopf;<sub>`pi`</sub>`[G_(t)\frac{&nabla;&pi;(A_(t) | S_(t),&theta;)}{&pi;(A_(t) | S_(t),&theta;)}]`</p>
		<p>Now, using eq(1) for stochastic gradient ascent,  we can get REINFORCE as:</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&theta;_(t+1) &esdot;&theta;_(t) + &alpha;G_(t)\frac{&nabla;&pi;(A_(t) | S_(t),&theta;)}{&pi;(A_(t) | S_(t),&theta;)}`</p>
		<p>And, as REINFORCE uses the complete return from time `t` which includes all future rewards up until the end of the episode, it is in a sense Monte Carlo Algorithm - yielding slow learning and high variance. </p>
		<p><b>REINFORCE with Baseline</b></p>
		<p>Policy gradient theorem of eq(2) can be generalized to include a comparison of the action value to an arbitary baseline <i>b(s)</i> :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&nabla;J(&theta;)&prop;\sum_{s}&mu;(s)\sum_{a}(q_(&pi;)(s,a)-b(s))&nabla;&pi;(a |s,&theta;)`&emsp;&emsp;&emsp;&emsp;&emsp;...eq(5)</p>
		<p>The baseline can be any function, even a random variable, as long as it doesn't vary with `a`. It is just introduced to significantly reduce the variance, thus speed up the learning process.</p>
		<p>The policy gradient theorem with baseline in eq(5) can be used to derive an update rule using steps as in earlier discussion. New version of REINFORCE with update rule that includes baseline is as follows :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`&theta;_(t+1)&esdot;+&alpha;(G_(t)-b(S_(t)))\frac{&nabla;&pi;(A_(t) | S_(t),&theta;_(t))}{&pi;(A_(t) | S_(t),&theta;_(t))}`</p>



</body>
</html>
