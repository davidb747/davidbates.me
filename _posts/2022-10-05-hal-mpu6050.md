---
layout: article
title: 【SMT32 HAL】基于HAL的MPU6050驱动
key: hal-mpu6050
permalink: /article/:title.html
tags: 
  - STM32
  - HAL
  - Cortex-M3
  - MPU6050
  - I2C
author: Yu Xiaoyuan
show_author_profile: true
license: WTFPL
---

在收拾旧物的时候翻出来之前一个未完成的LED显示项目，在后续开发过程中为该项目写了一个MPU6050的驱动库。

<!--more-->

## 电路

在之前的项目中经常使用这款STM32F103C8T6最小系统板，国外论坛管这个板子叫Bluepill。

![STM32F103C8T6最小系统板-Bluepill](/assets/images/2022-10-05-hal-mpu6050/Bluepillpinout.jpg "洋鬼子搞的引脚图还是挺细致的"){:.rounded}

之前开发时在上面焊接了8个LED灯珠，电路图大致如下。

![LED连接原理图](/assets/images/2022-10-05-hal-mpu6050/LED-connection.png "没错就是这么简单"){:.rounded}

这样的电路设计可能不太符合常规的设计规范，但如果使用合适封装的贴片LED，你就可以将LED直接焊在最小系统板上，整个电路能实现体积上的最小。
如下图是笔者焊接好的效果。

![焊接好的LED](/assets/images/2022-10-05-hal-mpu6050/soldered-led.jpg "不能说是工艺巧夺天工，只能说是设计独具匠心")

## 构想

笔者设想通过某种方式用这8个LED模拟点阵屏来进行显示。
点阵屏一般是扫描显示，比如对于一个$8\times8$点阵屏，对于每一时刻来说只有一列（或者一行）的灯珠是点亮的。
利用人眼的视觉暂留，控制器快速扫描每一列（或者每一行），造成一个完整显示的假象。

现在笔者有一个单列LED，只需让这一列LED动起来，这样在所有不同位置的这一列LED就构成了一个等效点阵屏。
动的方式也很简单，可以是围绕一点的匀速圆周运动（比如绕PC15引脚的旋转）或者干脆像摇手指一样来回甩这一列LED。

![摇手指示意图](/assets/images/2022-10-05-hal-mpu6050/finger-shaking.webp "甩得够快就是一片手指"){:.rounded}

## LED控制实现

构思有了，现在只需要控制就行了。

### 关键帧的显示

首先注意到，根据电路图，这8个LED不能同时点亮，可以间隔的四个LED分两组分别控制。笔者犯懒，一个一个控制写个循环扫描挺方便的。
所以即使是这单列LED也是利用视觉暂留效果进行单列显示。

在摇动过程中，需要不断切换单列显示的画面，我将这个被显示的画面称为关键帧。
8个LED的亮灭可以用1字节的数据来表征，所以每个关键帧是1字节，这样一个稍微复杂的二维静态画面可以用一个`uint8_t`的数组来表征。

比如显示几个字母。

![FUCK](/assets/images/2022-10-05-hal-mpu6050/static-image-fuck.jpg "黄色代表不亮，蓝色代表点亮，靠上的格子代表高位")

首先定义字母的静态外形，用宏定义来实现。

```c
...
#define CHAR_C 0x7E,0x81,0x81,0x81,0x42
...
#define CHAR_F 0xFF,0x90,0x90,0x90,0x80
...
#define CHAR_K 0xFF,0x10,0x28,0x44,0x83
...
#define CHAR_U 0xFE,0x01,0x01,0x01,0xFE
...
```

然后定义一个常量数组来描述整个显示的画面，用一个指针指向当前正在显示的关键帧。

```c
const uint8_t led_frames[] = {
  0x00, CHAR_F, 0x00, CHAR_U, 0x00, CHAR_C, 0x00, CHAR_K, 0x00
};
const uint8_t *p_current_frame = led_frames;
const uint16_t frame_count = sizeof(led_frames);
```

在主函数里进行单个LED的扫描显示。

```c
// include files ...
// macro ...

#define BIT_IN_VAL(val, bit) (((val) >> (bit)) & 0x01)

// defines ...

int main(void) {

  // some code ...

  /* USER CODE BEGIN 2 */
  // 看好了赛博丁真, 按位或是这样用的
  const uint16_t led_pin_mask_all = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_SET);
  HAL_GPIO_WritePin(GPIOA, led_pin_mask_all, GPIO_PIN_SET);

  // other init code ...

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    for(int j = 0; j < 8; j++)
    {
      HAL_GPIO_WritePin(GPIOA, led_pin_mask_all, GPIO_PIN_SET);
      HAL_GPIO_WritePin(GPIOA, 1 << j, BIT_IN_VAL(~*p_current_frame, j));
    }
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}
```

### 关键帧的切换

能显示关键帧了，如何切换呢？

首先想到的最直观的方法是隔一段时间来进行切换，如果在主函数里来实现的话可以理解为“当前帧显示若干次之后切换”。

这种切换方式非常原始，很不方便也不稳定。需要定时的功能肯定是从定时计数器中断来实现了。配置定时计数器溢出中断并编写中断服务函数来切换显示指针就可以了。

首先在CubeMX里配置时钟。选择8MHz外部高速时钟，9倍频后作为系统时钟，最后分配给各外设。注意到笔者的配置结果无论是APB1还是APB2的定时计数器时钟都是72MHz。

![时钟配置界面](/assets/images/2022-10-05-hal-mpu6050/F103-clock-configuration.png "最大72MHz，那就按最大来")

之后配置定时计数器TIM4。选择内部时钟信号，预分频器（PSC）设置35，设置增计数模式，计数周期设置为499，自动预装载。然后在NVIC选项卡开启全局中断。

![TIM4配置界面](/assets/images/2022-10-05-hal-mpu6050/F103-tim4-configuration.jpg )

## 参考

[STM32F103C8T6 STM32开发板最小系统板单片机核心板 学习板实验板](https://detail.tmall.com/item.htm?spm=a230r.1.14.20.7f322b62uM3tGB&id=524999349557&ns=1&abbucket=13)

[使用HAL库开发STM32：Timer基础说明与定时功能使用](https://blog.csdn.net/Naisu_kun/article/details/118703547)

[STM32 HAL library for GY-521 (MPU6050) with Kalman filter](https://github.com/leech001/MPU6050)
