---
layout: article
title: AutoEncoder and its Variants
date: 2022-07-14
sidebar:
  nav: "docs-en"
---


<html>


<!--- Adding Google Analytics -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154990580-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154990580-2');
</script>
<!-- End of Google Analytics Code -->

<script>
	MathJax = {
	  TeX: {
		inlineMath: [['$', '$'], ['\\(', '\\)']]
	  }
	};
	</script>

<!-- Adding MathJAX -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script async="true" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=AM_CHTML"> </script>
<!-- End of MathJAX -->


<body>
		<p>AutoEncoders are a specific kind of neural networks, a bridge between supervised and unsupervised. It first encodes the input into a compressed form and learns from it in an
		un-supervised manner a meaningful representation that helps to decode it back into a re-constructed input, hopefully as similar as the original input.<br>
		When it was first introduced, it was used with <i>linear activation function</i> as a technique for dimensionality reduction.</p>
		<h2>AutoEncoder (AE) Architecture</h2>
		<p>AE consists of an encoder and decoder, where the encoder is a function `f` that maps an input `x&isin;&Ropf;^d` to hidden representation `h(x) &isin;&Ropf;^d`. The Encoder has the form:</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`h = f(x) = s_{f}(Wx + b_(h))`</p>	
		<p>where `s_(f)` is a <i>non-linear activation function</i>, typically a sigmoid function`(z) = \frac{1}{1+e^(-z)}`. The encoder is parameterized by a `d_(h)&times;d_(x)` weight matrix `W`, and a bias vector `b_(h)&isin;&Ropf;^d`</p>
		<p>Similarly, the decoder function `g` maps hidden representation `h` back to a reconstruction `y`</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`y = g(h) = s_(g)(W'h + b_(y))`</p>
		<p>where, `s_(g)` is the decoder's activation function, typically either the identity <i>(yielding linear reconstruction)</i> or a sigmoid. The decoder's parameters are a bias vector `b_(y)&isin;&Ropf;^d`, and matrix `W'`</p>
		<p>While training AutoEncoder, we try to find parameters `&theta; = {W,b_(h),b_(y)}` that minimizes the reconstruction error on a training set of examples `D_(n)`. Then, our objective function can be written as :</p>
		<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`J_(AE)(&theta;) = \sum_{x&isin;D_(n)} L(x,g(f(x)))`</p>
		<p>where, `L` is the reconstruction error. Usually, it is `l_(2)` norm i.e, `L(x,y) = ||x-y||^2` in cases of linear reconstruction, and the cross-entropy loss when `s_(g)` is the sigmoid. A basic AutoEncoder Architecture can be seen below :</p>
		<img src="assets/img/autoen.png" width="450" height="160" class="image_full">
		<h2>Regularized AutoEncoder</h2>
		<p>As AutoEncoder are in a way a tool for feature extraction, and therefore, it is always better to have more and more features extracted from the input. If we leave hidden node with less than the size of node in input, it can overfit.<br>
		On the other hand, if we add equal or greater number of nodes in the hidden layer than the input node, it will simply the learn and pass the input representation. This is the case, we call - <u>over-complete hidden layer</u><br>
		Therefore, we need to have some additional regularization added into network, so that more and more feature can be extracted into representation, without being overfit, and underfit. Few key Regularized AutoEncoder are discussed below :</p>
		<p><b>Sparse AutoEncoders</b></p>
		<p>In Sparse AutoEncoder, there are actually two ways to enforce sparsity regularization, where regularization is applied on the activations instead of the weights.<br>
		First way to induce sparsity is to apply `L_(1)` regularization, the autoencoder optimization then becomes :</p>
		<p style="font-size: 18px;">&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`J_(SparseAE) = (\sum_{x&isin;D_(n)}L(x,g(f(x)))) + &lambda; \sum_{i}|a_(i)|`</p>
		<p>where, `a_(i)` is the activation at the `i`-th hidden layer and `i` iterates over all the hiddens activations.</p>
		<p>Second way is to use KL-divergence, which is a measure of the distance between two probability distributions. here, we assume the activation of each neuron acts as a Bernoulli variable with probability `p`. Then, at each batch, the actual probability is then measured, and the difference between two `p` distribution is applied as a regularization factor. <br>
		For each neuron `j`, the calculated empirical probability is `p'_(j) = \frac{1}{m}\sum_{i}a_(i)(x)`, where `i` iterates over the samples in the batch. The overall loss function then becomes : </p>
		<p style="font-size: 18px;">&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;`J_(SparseAE) = (\sum_{x&isin;D_(n)}L(x,g(f(x)))) + \sum_{j} KL (p||p'_(j))`</p>
		<p>where, the regularization term in it aims at matching `p` to `p'`</p>


</body>
</html>
